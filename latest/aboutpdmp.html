<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>About PDMP · PDMP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><link href="assets/partial.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PDMP.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li class="current"><a class="toctext" href="aboutpdmp.html">About PDMP</a><ul class="internal"><li><a class="toctext" href="#Basic-idea-(global-samplers)-1">Basic idea (global samplers)</a></li><li><a class="toctext" href="#Local-Samplers-1">Local Samplers</a></li><li><a class="toctext" href="#References-1">References</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="examples/ex_gbps1.html">Global BPS</a></li><li><a class="toctext" href="examples/ex_lbps1.html">Local BPS</a></li></ul></li><li><span class="toctext">Technical Documentation</span><ul><li><a class="toctext" href="techdoc/structure.html">Code structure</a></li><li><a class="toctext" href="techdoc/types.html">Types</a></li></ul></li><li><span class="toctext">Contributing</span><ul><li><a class="toctext" href="contributing/addingexample.html">Examples</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="aboutpdmp.html">About PDMP</a></li></ul><a class="edit-page" href="https://github.com/alan-turing-institute/PDMP.jl/tree/94a5c72e33b7ca3e8c097535efee400032f07857/docs/src/aboutpdmp.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>About PDMP</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="About-PDMP-samplers-1" href="#About-PDMP-samplers-1">About PDMP samplers</a></h1><p>This page aims at giving a very brief introduction to the concept of PDMP samplers (below we will refer to <em>the algorithm</em> but it should be understood as a class of algorithms). We also give some insight into how it is implemented although we cover the implementation in more details in the technical documentation. This is not meant to be a rigorous presentation of the algorithm (for this, please see the references at the bottom of this page). Rather, we focus here on the &quot;large building blocks&quot; behind the algorithm.</p><h2><a class="nav-anchor" id="Basic-idea-(global-samplers)-1" href="#Basic-idea-(global-samplers)-1">Basic idea (global samplers)</a></h2><p>The purpose of the algorithm is to be able to evaluate expected values with respect to an arbitrary target distribution which we assume admits a probability density function  <span>$\pi$</span>. For simplicity, we assume that <span>$\pi:C\to \mathbb R^+$</span> with <span>$C\subseteq \mathbb R^p$</span>, convex. The objective is therefore to compute a weighted integral of the form:</p><p>\begin{equation}     \mathbb E_{\pi}[\varphi(X)] = \int_{C} \varphi(x)\pi(x)\,\mathrm{d}x \end{equation}</p><p>The samples considered generate a <em>piecewise-linear path</em></p><p>\begin{equation}     x(t) = x^{(i)} + v^{(i)}(t-t_i) \quad \text{for}\quad t\in[t_i, t_{i+1}] \end{equation}</p><p>determined by an initial position <span>$x^{(0)}$</span> and velocity <span>$v^{(0)}$</span> at time <span>$t_0=0$</span> and a set of positive <em>event times</em> <span>$t_1,t_2,\dots$</span>. Under some conditions for the generation of the times and the velocities, the expected value can be approximated with</p><p>\begin{eqnarray}     \mathbb E_{\pi}[\varphi(X)] &amp;\approx&amp; {1\over T} \int_0^T\varphi(x(t))\mathrm{d}t \end{eqnarray}</p><p>and the integral in the right hand side can be expressed as a sum of one-dimensional integrals along each linear segment.</p><h3><a class="nav-anchor" id="Generating-times-and-velocities-1" href="#Generating-times-and-velocities-1">Generating times and velocities</a></h3><p>The algorithm generates a sequence of <em>triples</em> of the form <span>$(t^{(i)}, x^{(i)}, v^{(i)})$</span>. Let us assume that the algorithm is currently at one of those event points and show how to compute the next triple. To do so, the algorithm executes the following steps:</p><ol><li><p>it generates a travel time <span>$\tau$</span> drawing from a specific process,</p></li><li><p>the next position is obtained by traveling along the current <em>ray</em> for the travel time <span>$\tau$</span> i.e.: <span>$x^{(i+1)} = x^{(i)} + \tau v^{(i)}$</span>,</p></li><li><p>a new velocity <span>$v^{(i+1)}$</span> is generated.</p></li></ol><p>First we will explore how the travel time is generated and then how the new velocity is computed.</p><h4><a class="nav-anchor" id="Sampling-a-travel-time-1" href="#Sampling-a-travel-time-1">Sampling a travel time</a></h4><p>The travel time <span>$\tau$</span> is obtained as the minimum of three times which we will denote by <span>$\tau_b, \tau_h, \tau_r$</span>. Following the case, the computation of the new velocity will be different.</p><p>The first (and most important) one, <span>$\tau_b$</span>, is the first arrival time of an <em>Inhomogenous Poisson Process</em> (IPP) with an intensity that should verify some properties with respect to the target distribution. The <em>Bouncy Particle Sampler</em> (BPS) in particular considers the following intensity with <span>$U$</span> the log-likelihood of the (unnormalised) target <span>$\pi$</span>:</p><p>\begin{eqnarray}     \lambda(\tau; x, v) = \langle \nabla U(x + \tau v ), v \rangle^+ \end{eqnarray}</p><p>where <span>$x$</span> and <span>$v$</span> are the current points and <span>$f^+=\max(f,0)$</span>. Sampling from an IPP is not trivial in general but there are a few well known techniques that can be applied depending on the target.</p><p>The other two times are easy to compute:</p><ul><li><p>the first, <span>$\tau_h$</span>, is the time of first hit with the boundary of the domain <span>$C$</span> along the current ray <span>$x(t)=x^{(i)}+(t-t_i)v^{(i)}$</span> for <span>$t&gt;t_i$</span>. This guarantees that the trajectory stays in <span>$C$</span>.</p></li><li><p>the second, <span>$\tau_r$</span>, is a <em>refreshment time</em> sampled from an exponential distribution with a fixed rate. This guarantees full exploration of <span>$C$</span> (see BPS paper for details).</p></li></ul><h4><a class="nav-anchor" id="Computing-a-new-velocity-(BPS)-1" href="#Computing-a-new-velocity-(BPS)-1">Computing a new velocity (BPS)</a></h4><p><em>Below we discuss the case of the BPS, the computations can be different for different samplers (such as the ZZ) but the essence of the method is the same.</em></p><p>As mentioned above, we take <span>$\tau = \min(\tau_b, \tau_h, \tau_r)$</span>. Depending on the case, three actions can be taken</p><ol><li><p>a <strong>bounce</strong> with <span>$\tau = \tau_b$</span> where the new velocity is obtained by specular reflection against the tangent to the gradient of the log-likelihood at the point <span>$x(\tau_b)$</span>,</p></li><li><p>a <strong>boundary bounce</strong> with <span>$\tau=\tau_{h}$</span> where the new velocity is obtained by specular reflection against the tangent to the boundary at the point of hit <span>$x(\tau_h)$</span>,</p></li><li><p>a <strong>refreshment</strong> with <span>$\tau=\tau_r$</span> where the new velocity is drawn from a reference process such as a spherical Gaussian.</p></li></ol><p>The update of the velocity goes as follows for the BPS (specular reflection):</p><p>\begin{equation}     v \leftarrow v - 2\langle \nabla U(x), v\rangle{\nabla U(x)\over \|\nabla U(x)\|^2}. \end{equation}</p><p>The figure below illustrates the specular reflexion, starting at the red point and going along the current ray (red, dashed line), we have a new event corresponding to a bounce or a hit (blue dot). In both case a specular reflection is executed (blue dashed line). The black line represents the tangent to either the boundary at that point or to the log-likelihood depending on the case.</p><p><img src="assets/BPS.svg" alt/></p><h3><a class="nav-anchor" id="Putting-the-pieces-together-1" href="#Putting-the-pieces-together-1">Putting the pieces together</a></h3><p>The simple global sampler can be expressed as follows:</p><blockquote><ol><li><p>Initialize <span>$(x^{(0)}, v^{(0)})$</span> and <span>$T$</span> the trajectory length</p></li><li><p>For <span>$i=1,2,\dots$</span>, consider the ray <span>$x^{(i-1)}+\tau v^{(i-1)}$</span></p><ol><li><p>Simulate <span>$\tau_b$</span> from an IPP along the ray</p></li><li><p>Compute <span>$\tau_h$</span>, simulate <span>$\tau_r$</span> and let <span>$\tau=\min(\tau_h,\tau_r,\tau_b)$</span></p></li><li><p>Following the case in (2.) compute the new velocity <span>$v^{(i)}$</span></p></li><li><p>Store the new triple <span>$(t_{i-1}+\tau, x^{(i-1)}+\tau v^{(i-1)}, v^{(i)})$</span></p></li><li><p>if <span>$t_i \ge T$</span> stop.</p></li></ol></li><li><p>Return the path: <span>$\{(t_i, x^{(i)}, v^{(i)})\}_{i=0,1,\dots}$</span></p></li></ol></blockquote><p>Here are a few key building blocks that can be found in the code</p><ul><li><p>A way to sample from an IPP (see <code>ippsampler.jl</code>)</p></li><li><p>A way to define the geometry and in particular to compute the next boundary hit when traveling along a given ray</p></li></ul><h2><a class="nav-anchor" id="Local-Samplers-1" href="#Local-Samplers-1">Local Samplers</a></h2><h2><a class="nav-anchor" id="References-1" href="#References-1">References</a></h2><ul><li><p>Alexandre Bouchard-Côté, Sebastian J. Vollmer and Arnaud Doucet, <a href="https://arxiv.org/abs/1510.02451"><em>The Bouncy Particle Sampler: A Non-Reversible Rejection-Free Markov Chain Monte Carlo Method</em></a>, arXiv preprint, 2015.</p></li><li><p>Joris Bierkens, Alexandre Bouchard-Côté, Arnaud Doucet, Andrew B. Duncan, Paul Fearnhead, Gareth Roberts and Sebastian J. Vollmer, <a href="https://arxiv.org/pdf/1701.04244.pdf"><em>Piecewise Deterministic Markov Processes for Scalable Monte Carlo on Restricted Domains</em></a>, arXiv preprint, 2017.</p></li><li><p>Joris Bierkens, Paul Fearnhead and Gareth Roberts, <a href="https://arxiv.org/pdf/1607.03188.pdf"><em>The Zig-Zag Process and Super-Efficient Sampling for Bayesian Analysis of Big Data</em></a>, arXiv preprint, 2016.</p></li></ul><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="examples/ex_gbps1.html"><span class="direction">Next</span><span class="title">Global BPS</span></a></footer></article></body></html>
