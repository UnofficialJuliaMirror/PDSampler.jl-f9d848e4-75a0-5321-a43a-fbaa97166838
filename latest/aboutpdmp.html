<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>About PDMP · PDMP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><link href="assets/partial.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PDMP.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li class="current"><a class="toctext" href="aboutpdmp.html">About PDMP</a><ul class="internal"></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="examples/ex_gbps1.html">Global BPS</a></li><li><a class="toctext" href="examples/ex_lbps1.html">Local BPS</a></li></ul></li><li><span class="toctext">Technical Documentation</span><ul><li><a class="toctext" href="techdoc/structure.html">Code structure</a></li><li><a class="toctext" href="techdoc/types.html">Types</a></li></ul></li><li><span class="toctext">Contributing</span><ul><li><a class="toctext" href="contributing/addingexample.html">Examples</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="aboutpdmp.html">About PDMP</a></li></ul><a class="edit-page" href="https://github.com/alan-turing-institute/PDMP.jl/tree/c2ee0633d40cd7b378a6c40cba098ec41138d02b/docs/src/aboutpdmp.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>About PDMP</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="About-PDMP-samplers-1" href="#About-PDMP-samplers-1">About PDMP samplers</a></h1><p>This page aims at giving a very brief introduction to the concept of PDMP samplers (below we will refer to <em>the algorithm</em> but it should be understood as a class of algorithms). We also give some insight into how it is implemented although we cover the implementation in more details in the technical documentation. This is not meant to be a rigorous presentation of the algorithm (for this, please see the references at the bottom of this page). Rather, we focus here on the &quot;large building blocks&quot; behind the algorithm.</p><h3><a class="nav-anchor" id="Basic-idea-(global-samplers)-1" href="#Basic-idea-(global-samplers)-1">Basic idea (global samplers)</a></h3><p>The purpose of the algorithm is to be able to evaluate expected values with respect to an arbitrary target distribution which we assume admits a probability density function  <span>$\pi$</span>. For simplicity, we assume that <span>$\pi:C\to \mathbb R^+$</span> with <span>$C\subseteq \mathbb R^p$</span>, convex. The objective is therefore to compute a weighted integral of the form:</p><p>\begin{equation}     \mathbb E_{\pi}[\varphi(X)] = \int_{C} \varphi(x)\pi(x)\,\mathrm{d}x \end{equation}</p><p>The samples considered generate a <em>piecewise-linear path</em></p><p>\begin{equation}     x(t) = x^{(i)} + v^{(i)}(t-t_i) \quad \text{for}\quad t\in[t_i, t_{i+1}] \end{equation}</p><p>determined by an initial position <span>$x^{(0)}$</span> and velocity <span>$v^{(0)}$</span> and a set of positive <em>event times</em> <span>$t_1,t_2,\dots$</span>. Under some conditions for the generation of the times and the velocities, the expected value can be approximated with</p><p>\begin{eqnarray}     \mathbb E_{\pi}[\varphi(X)] &amp;\approx&amp; {1\over T} \int_0^T\varphi(x(t))\mathrm{d}t \end{eqnarray}</p><p>and the integral in the right hand side can be expressed as a sum of integrals along each linear segment.</p><h4><a class="nav-anchor" id="Generating-times-and-velocities-1" href="#Generating-times-and-velocities-1">Generating times and velocities</a></h4><p>As we have seen, this class of samplers generate <em>triples</em> of the form <span>$(t^{(i)}, x^{(i)}, v^{(i)})$</span>. Let us assume that the algorithm is currently at one of those event points. Then, the algorithm considers the <em>ray</em></p><p>\begin{equation}     x(t) = x^{(i)} + (t-t^{(i)})v^{(i)} \end{equation}</p><p>for <span>$t&gt;t_i$</span>. The next event will happen on this ray at a time <span>$t_i+\tau$</span> and be located at <span>$x^{(i+1)} = (x^{(i)}+\tau v^{(i)})$</span>. We will see in a moment how <span>$\tau$</span> should be generated. At that new point, the velocity will be recomputed following one of three possible action:</p><ol><li><p>a <strong>bounce</strong> with <span>$\tau = \tau_b$</span> where a velocity is recomputed following the value of the gradient of the log-likelihood of the target (see below),</p></li><li><p>a <strong>boundary bounce</strong> with <span>$\tau=\tau_{h}$</span> where the velocity is reflected against a boundary of the domain <span>$C$</span>,</p></li><li><p>a <strong>refreshment</strong> with <span>$\tau=\tau_r$</span> where the velocity is &quot;refreshed&quot;.</p></li></ol><p>A time <span>$\tau$</span> is drawn, if  <span>$\tau\le \min(\tau_h,\tau_r)$</span>, step (1) is applied. If <span>$\tau \ge \tau_r$</span> step (3) is applied. Otherwise step (2). Both <span>$\tau_h$</span> and <span>$\tau_r$</span> should be considered given. The first one, <span>$\tau_h$</span> is the hitting time between the ray and the closest boundary of <span>$C$</span> (for simple domains like a polygonal domain it can be computed analytically). The second one, <span>$\tau_r$</span> is drawn from an exponential distribution (this allows to guarantee that the algorithm explores the whole space).</p><p>It remains to explain how to generate <span>$\tau$</span> and how the velocity is updated.</p><p>The time <span>$\tau$</span> is the first arrival time of an <em>Inhomogenous Poisson Process</em> (IPP) with an intensity that should verify some properties. The <em>Bouncy Particle Sampler</em> (BPS) in particular considers the following intensity with <span>$U$</span> the log-likelihood of the (unnormalised) target <span>$\pi$</span>:</p><p>\begin{eqnarray}     \lambda(t; x, v) = \langle \nabla U(x + tv ), v \rangle^+ \end{eqnarray}</p><p>where <span>$x^+=\max(x,0)$</span>. Sampling from an IPP is not trivial in general, a few methods can be applied as discussed in the next point.</p><p>The update of the velocity goes as follows for the BPS:</p><ul><li><p>(<strong>bounce</strong>) the new velocity is obtained by computing a specular reflection of the velocity against the tangent to the gradient of the log-likelihood at <span>$x(t+\tau_b)$</span> is computed</p></li></ul><p>\begin{equation}     v \leftarrow v - 2\langle \nabla U(x), v\rangle{\nabla U(x)\over \|\nabla U(x)\|^2} \end{equation}</p><ul><li><p>(<strong>boundary hit</strong>) the new velocity is obtained by computing a specular reflection against the tangent to the boundary at the hitting point.</p></li><li><p>(<strong>refresh</strong>) the new velocity is obtained by sampling from a &quot;refreshment distribution&quot; for example a <span>$\mathcal N(0, I)$</span>.</p></li></ul><p>The illustration below illustrates the specular reflexion, starting at the red point and going along the ray (red, dashed line), we could have a new event corresponding to bounce or a hit (blue dot). In both case a specular reflection is executed (blue dashed line).</p><p><img src="assets/BPS.svg" alt/></p><h4><a class="nav-anchor" id="Sampling-from-an-IPP-1" href="#Sampling-from-an-IPP-1">Sampling from an IPP</a></h4><h3><a class="nav-anchor" id="Local-Samplers-1" href="#Local-Samplers-1">Local Samplers</a></h3><h3><a class="nav-anchor" id="References-1" href="#References-1">References</a></h3><ul><li><p>Alexandre Bouchard-Côté, Sebastian J. Vollmer and Arnaud Doucet, <a href="https://arxiv.org/abs/1510.02451"><em>The Bouncy Particle Sampler: A Non-Reversible Rejection-Free Markov Chain Monte Carlo Method</em></a>, arXiv preprint, 2015.</p></li><li><p>Joris Bierkens, Alexandre Bouchard-Côté, Arnaud Doucet, Andrew B. Duncan, Paul Fearnhead, Gareth Roberts and Sebastian J. Vollmer, <a href="https://arxiv.org/pdf/1701.04244.pdf"><em>Piecewise Deterministic Markov Processes for Scalable Monte Carlo on Restricted Domains</em></a>, arXiv preprint, 2017.</p></li><li><p>Joris Bierkens, Paul Fearnhead and Gareth Roberts, <a href="https://arxiv.org/pdf/1607.03188.pdf"><em>The Zig-Zag Process and Super-Efficient Sampling for Bayesian Analysis of Big Data</em></a>, arXiv preprint, 2016.</p></li></ul><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="examples/ex_gbps1.html"><span class="direction">Next</span><span class="title">Global BPS</span></a></footer></article></body></html>
