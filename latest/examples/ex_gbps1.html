<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Global BPS · PDMP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/partial.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PDMP.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Introduction</a></li><li><a class="toctext" href="../aboutpdmp.html">About PDMP</a></li><li><span class="toctext">Examples</span><ul><li class="current"><a class="toctext" href="ex_gbps1.html">Global BPS</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#here-we-build-a-valid-precision-matrix.-The-cholesky-decomposition-of#-the-covariance-matrix-will-be-useful-later-to-build-a-sensible#-starting-point-for-the-algorithm.srand(12)P1-randn(p,p)P1-*-P1&#39;P1-norm(P1)/100*eye(p)C1-inv(P1);-C1-C1&#39;;-C1/2;L1-cholfact(C1)mu-zeros(p)1.mvg-MvGaussianCanon(mu,-P1)-1">here we build a valid precision matrix. The cholesky decomposition of# the covariance matrix will be useful later to build a sensible# starting point for the algorithm.srand(12)P1  = randn(p,p)P1 <em>= P1&#39;P1 += norm(P1)/100</em>eye(p)C1  = inv(P1); C1 += C1&#39;; C1/=2;L1  = cholfact(C1)mu  = zeros(p)+1.mvg = MvGaussianCanon(mu, P1)```</a></li><li class="toplevel"><a class="toctext" href="#Building-a-basic-MC-estimator#-(taking-samples-from-2D-MVG-that-are-in-positive-orthan)sN-1000s-broadcast(,-mu,-L1[:L]*randn(p,sN))mt-zeros(2)np-0#-Sum-for-all-samples-in-the-positive-orthanss-[s;-ones(sN)&#39;]mt-sum(ss[:,i]-for-i-in-1:sN-if-!any(e-e0,-ss[1:p,i]))mt-mt[1:p]/mt[end]-1">Building a basic MC estimator# (taking samples from 2D MVG that are in positive orthan)sN = 1000s  = broadcast(+, mu, L1[:L]*randn(p,sN))mt = zeros(2)np = 0# Sum for all samples in the positive orthanss = [s; ones(sN)&#39;]mt = sum(ss[:,i] for i in 1:sN if !any(e-&gt;e&lt;0, ss[1:p,i]))mt = mt[1:p]/mt[end]```</a></li></ul></li><li><a class="toctext" href="ex_lbps1.html">Local BPS</a></li></ul></li><li><span class="toctext">Technical Documentation</span><ul><li><a class="toctext" href="../techdoc/structure.html">Code structure</a></li><li><a class="toctext" href="../techdoc/coretools.html">Core tools</a></li><li><a class="toctext" href="../techdoc/models.html">Models</a></li><li><a class="toctext" href="../techdoc/global.html">Global sampler</a></li><li><a class="toctext" href="../techdoc/local.html">Local sampler</a></li></ul></li><li><span class="toctext">Contributing</span><ul><li><a class="toctext" href="../contributing/addingexample.html">New example</a></li><li><a class="toctext" href="../contributing/addingfeature.html">New feature</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Examples</li><li><a href="ex_gbps1.html">Global BPS</a></li></ul><a class="edit-page" href="https://github.com/alan-turing-institute/PDMP.jl/tree/759385baeff165d5f99d752922217aa59cc14a54/docs/src/examples/ex_gbps1.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Global BPS</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Global-BPS-(Truncated-Gaussian)-1" href="#Global-BPS-(Truncated-Gaussian)-1">Global BPS (Truncated Gaussian)</a></h1><p>(<em>the code for this example can be found <a href="https://github.com/alan-turing-institute/PDMP.jl/blob/master/test/ex_gbps1.jl">here</a>, note that the doc rendered here was automatically generated, if you want to fix it, please do it in the julia code directly</em>)</p><p>In this example we use the global Bouncy Particle Sampler on 2D Gaussian truncated to the positive orthan to show how to declare a BPS model.<img src="../assets/truncatedgaussian.png" alt/>Start by loading the library:<code>julia using PDMP</code> you then need to define two elements:1. a geometry (boundaries)2. an energy (gradient of the log-likelihood of the target)The positive orthan corresponds to a simple Polygonal domain where the boundaries are the axes. The normal to these boundaries (<code>ns</code>) are therefore unit vectors and the intercepts (<code>a</code>) are zero.A polygonal domain is then declared with the constructor <code>Polygonal</code>.<code>julia p = 2# normal to faces and interceptsns, a = eye(p), zeros(p)geom  = Polygonal(ns, a)</code> The function <code>nextboundary</code> returns a function that can compute the next boundary on the current ray <code>[x,x+tv]</code> with <code>t&gt;0</code> as well as the time of the hit.<code>julia nextbd(x, v) = nextboundary(geom, x, v)</code> The model then needs to be specified: you need to define a function of the form<code>gradll(x)</code> which can return the gradient of the log-likelihood at some point <code>x</code>.Here, let us consider a 2D gaussian.```julia</p><h1><a class="nav-anchor" id="here-we-build-a-valid-precision-matrix.-The-cholesky-decomposition-of#-the-covariance-matrix-will-be-useful-later-to-build-a-sensible#-starting-point-for-the-algorithm.srand(12)P1-randn(p,p)P1-*-P1&#39;P1-norm(P1)/100*eye(p)C1-inv(P1);-C1-C1&#39;;-C1/2;L1-cholfact(C1)mu-zeros(p)1.mvg-MvGaussianCanon(mu,-P1)-1" href="#here-we-build-a-valid-precision-matrix.-The-cholesky-decomposition-of#-the-covariance-matrix-will-be-useful-later-to-build-a-sensible#-starting-point-for-the-algorithm.srand(12)P1-randn(p,p)P1-*-P1&#39;P1-norm(P1)/100*eye(p)C1-inv(P1);-C1-C1&#39;;-C1/2;L1-cholfact(C1)mu-zeros(p)1.mvg-MvGaussianCanon(mu,-P1)-1">here we build a valid precision matrix. The cholesky decomposition of# the covariance matrix will be useful later to build a sensible# starting point for the algorithm.srand(12)P1  = randn(p,p)P1 <em>= P1&#39;P1 += norm(P1)/100</em>eye(p)C1  = inv(P1); C1 += C1&#39;; C1/=2;L1  = cholfact(C1)mu  = zeros(p)+1.mvg = MvGaussianCanon(mu, P1)```</a></h1><p>Here, we have defined the gaussian through the <em>Canonical</em> representation i.e.: by specifying a mean and a precision matrix.Every model must implement a <code>gradloglik</code> function returning the gradient of the log-likelihood at a point <code>x</code>.<code>julia gradll(x) = gradloglik(mvg, x)</code> Next, you need to define the function which can return the first arrival time ofthe corresponding Inhomogenous Poisson Process.Note that you could be using <code>nextevent_zz</code> here as well if you wanted to usethe Zig-Zag sampler (and you could implement other kernels as well).<code>julia nextev(x, v) = nextevent_bps(mvg, x, v)</code> For a Gaussian (and some other simple distributions), this is analytical throughan inversion-like method.Finally, you need to specify the parameters of the simulation such as thestarting point and velocity, the length of the path generated, the rate ofrefreshment and the maximum number of gradient evaluations.<code>julia T    = 1000.0   # length of path generatedlref = 2.0      # rate of refreshmentx0   = mu+L1[:L]*randn(p) # sensible starting pointv0   = randn(p) # starting velocityv0  /= norm(v0) # put it on the sphere (not necessary)# Define a simulationsim = Simulation( x0, v0, T, nextev, gradll,                  nextbd, lref ; maxgradeval = 10000)</code> And finally, generate the path and recover some details about the simulation.<code>julia (path, details) = simulate(sim)</code> The <code>path</code> object belongs to the type <code>Path</code> and can be sampled using<code>samplepath</code>.A crude sanity check is for example to check that the estimated mean obtained through quadrature along the path yields a similar result as a basic Monte Carlo estimator.```julia</p><h1><a class="nav-anchor" id="Building-a-basic-MC-estimator#-(taking-samples-from-2D-MVG-that-are-in-positive-orthan)sN-1000s-broadcast(,-mu,-L1[:L]*randn(p,sN))mt-zeros(2)np-0#-Sum-for-all-samples-in-the-positive-orthanss-[s;-ones(sN)&#39;]mt-sum(ss[:,i]-for-i-in-1:sN-if-!any(e-e0,-ss[1:p,i]))mt-mt[1:p]/mt[end]-1" href="#Building-a-basic-MC-estimator#-(taking-samples-from-2D-MVG-that-are-in-positive-orthan)sN-1000s-broadcast(,-mu,-L1[:L]*randn(p,sN))mt-zeros(2)np-0#-Sum-for-all-samples-in-the-positive-orthanss-[s;-ones(sN)&#39;]mt-sum(ss[:,i]-for-i-in-1:sN-if-!any(e-e0,-ss[1:p,i]))mt-mt[1:p]/mt[end]-1">Building a basic MC estimator# (taking samples from 2D MVG that are in positive orthan)sN = 1000s  = broadcast(+, mu, L1[:L]*randn(p,sN))mt = zeros(2)np = 0# Sum for all samples in the positive orthanss = [s; ones(sN)&#39;]mt = sum(ss[:,i] for i in 1:sN if !any(e-&gt;e&lt;0, ss[1:p,i]))mt = mt[1:p]/mt[end]```</a></h1><p>You can now compare the norm of <code>mt</code> (a crude MC estimator) to <code>pathmean(path)</code> (computing the integrals along the segments of the path) and you will see thatthe relative error is below 5%.</p><footer><hr/><a class="previous" href="../aboutpdmp.html"><span class="direction">Previous</span><span class="title">About PDMP</span></a><a class="next" href="ex_lbps1.html"><span class="direction">Next</span><span class="title">Local BPS</span></a></footer></article></body></html>
