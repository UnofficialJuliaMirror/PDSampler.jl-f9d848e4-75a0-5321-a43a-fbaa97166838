<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Global BPS 1 · PDMP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PDMP.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Introduction</a></li><li><span class="toctext">Examples</span><ul><li class="current"><a class="toctext" href="bps_mvg_constr.html">Global BPS 1</a><ul class="internal"></ul></li><li><a class="toctext" href="lbps_gchain.html">Local BPS 1</a></li></ul></li><li><span class="toctext">Technical Documentation</span><ul><li><a class="toctext" href="../techdoc/types.html">Types</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Examples</li><li><a href="bps_mvg_constr.html">Global BPS 1</a></li></ul><a class="edit-page" href="https://github.com/alan-turing-institute/PDMP.jl/tree/dc700f34c3519d19ba7d7121e8fd0acf8ff2cc97/docs/src/examples/bps_mvg_constr.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Truncated-Multivariate-Gaussian-1" href="#Truncated-Multivariate-Gaussian-1">Truncated Multivariate Gaussian</a></h1><p>(<em>we follow here step by step <a href="https://github.com/alan-turing-institute/PDMP.jl/blob/master/example/bps_mvg_constr.jl">this example</a></em>)</p><p>Start by loading the library:</p><pre><code class="language-julia">using PDMP</code></pre><p>you will then need to define two things:</p><ol><li><p>a geometry (boundaries)</p></li><li><p>an energy (gradient of log-likelihood)</p></li></ol><p>At the moment, the package can handle unconstrained geometries and polygonal domains. Let&#39;s say we want to be constrained to the positive orthan in 2D:</p><pre><code class="language-julia">p                 = 2
ns, a             = eye(p), zeros(p)
geom              = PDMP.Polygonal(ns,a)
nextboundary(x,v) = PDMP.nextboundary(geom, x, v)</code></pre><p>Here <code>ns</code> and <code>a</code> are the normals and the intercepts of the facets. The type <code>Polygonal</code> encapsulates that geometry. The function <code>nextboundary</code> returns the next boundary on the current ray <code>[x,x+tv]</code> with <code>t&gt;0</code> as well as the time when that hit will happen.</p><p>We then need to specify a model, in particular we need to define a function of the form <code>gll(x)</code> which can return the gradient of the log-likelihood at <code>x</code>. Here let us consider a 2D gaussian for simplicity.</p><pre><code class="language-julia">P1  = randn(p,p)
P1 *= P1&#39;
mu  = zeros(p)+1.
mvg = PDMP.MvGaussianCanon(mu, P1)</code></pre><p>Here we have defined the gaussian through the &quot;Canonical&quot; representation (see <code>src/models/gaussian.jl</code> for others) i.e.: by specifying a mean and a precision matrix.</p><p>The gradient of the log-likelihood is then given by</p><pre><code class="language-julia">gll(x) = PDMP.gradloglik(mvg, x)</code></pre><p><strong>Remark</strong>: if you want to implement your own model, you should define your model in <code>src/models/yourmodel.jl</code> and make sure it implements a <code>gradloglik</code> function.</p><p>Next we need to define the function which can return the first arrival time of the IPP (see algorithm). Note that you could be using <code>nextevent_zz</code> here as well if you wanted the Zig-Zag sampler. See <code>src/ippsampler.jl</code> for more.</p><pre><code class="language-julia">nextevent(x, v) = PDMP.nextevent_bps(mvg, x, v)</code></pre><p>For a Gaussian (and some other simple functions), this is analytical through an inversion-like method (see BPS paper). Another approach is the thinning approach using a bounding intensity. At the moment thinning with a linear bound is implemented (cf. <code>src/ippsampler.jl</code>).</p><p>Finally, you need to specify the parameters of the simulation such as the starting point, velocity, length of the path generated, rate of refreshment and maximum number of gradient evaluations.</p><pre><code class="language-julia">T    = 1000.0   # length of path generated
lref = 2.0      # rate of refreshment
x0   = randn(p) # starting point
v0   = randn(p) # starting velocity
v0  /= norm(v0) # put it on the sphere (not necessary)

sim = PDMP.Simulation( x0, v0, T, nextevent, gll,
            nextboundary, lref ; maxgradeval = 10000)</code></pre><p>And finally, generate the path and recover some details about the simulation.</p><pre><code class="language-julia">(path, details) = PDMP.simulate(sim)</code></pre><p>The <code>path</code> object belongs to the type <code>Path</code> and can be sampled using <code>samplepath</code> (see <code>src/path.jl</code>).</p><footer><hr/><a class="previous" href="../index.html"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="lbps_gchain.html"><span class="direction">Next</span><span class="title">Local BPS 1</span></a></footer></article></body></html>
